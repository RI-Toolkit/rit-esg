#' esg_afns_simulator
#'
#' @description
#' The continuous-time economic scenario generator simulates the trajectories
#' of (in brackets are the `$names` of the output dataframes):
#'
#' (1) Australia zero-coupon bond rates maturing every quarter from 3 months up
#' to 10 years, i.e., 0.25 years (`$maturity_1qtrs`), 0.5 years
#' (`$maturity_2qtrs`), 0.75 years (`$maturity_3qtrs`), ...,
#' 10 years (`$maturity_40qtrs`),
#'
#' (2) NSW home value index (`$house_index`),
#'
#' (3) S&P/ASX200 price (`$stock_price`).
#'
#' The results are still depicted with the same simulation frequency options as
#' the discrete case, but the calculations are based in continuous time. Refer
#' to the section `details` for explanations of the mathematical model. This
#' function requires the package `MASS` for random number generation and `expm`
#'  for matrix exponential. Period-by-period summary statistics can be obtained
#'  from \code{esg_summary}.
#'
#' @details
#' The zero-coupon bond term structure is fitted using the arbitrage-free
#' Nelson-Siegel model, while NSW home value index and S&P/ASX200 price are
#' assumed to be Geometric Brownian Motions that are correlated with the
#' zero-coupon bond rates. Further details on model parameter estimation and
#' forecast can be found in note (a) below.
#'
#' The `independent`-factor model assumes that the level, slope, and curvature of
#' the risk-free rate are mutually independent, while the correlated-factor
#' model assumes dependence among them. Simulations generated by the
#' `correlated`-factor models are more volatile since more parameters are
#' involved. Further suggestions on model selection can be found in section
#' "Choosing an Appropriate Model" below.
#'
#' Denote \eqn{X^1} the level, \eqn{X^2} the slope, \eqn{X^3} the curvature of the risk-free
#' rate, \eqn{X^4} the logged NSW home value index, \eqn{X^5} the logged S&P/ASX200 price,
#' and \eqn{W^1, \cdots, W^5} the standard Brownian Motions. Under the real-world
#' measure, the `independent`-factor model satisfies the following stochastic
#' differential equations:
#'
#' \deqn{dX_t^1 = [\theta_1 - \kappa_{11}X_t^1] dt + \sigma_{11} dW_t^1,\\ dX_t^2 = [\theta_2 - \kappa_{22} X_t^2] dt + \sigma_{22} dW_t^2, \\ dX_t^3 = [\theta_3 - \kappa_{33} X_t^3] dt + \sigma_{33} dW_t^3,\\ dX_t^4 = [\theta_4 + X_t^1 + X_t^2] dt + \sum_{i=1}^4 \sigma_{4i} dW_t^i,\\ dX_t^5 = [\theta_5 + X_t^1 + X_t^2] dt + \sum_{i=1}^5 \sigma_{5i} dW_t^i,}
#'
#' while the `correlated`-factor model satisfies
#'
#' \deqn{dX_t^1 = [\theta_1 - \sum_{i=1}^3 \kappa_{1i} X_t^i] dt + \sigma_{11} dW_t^1,\\ dX_t^2 = [\theta_2 - \sum_{i=1}^3 \kappa_{2i} X_t^i] dt + \sum_{i=1}^2 \sigma_{2i} dW_t^i,\\ dX_t^3 = [\theta_3 - \sum_{i=1}^3 \kappa_{3i} X_t^i] dt + \sum_{i=1}^3 \sigma_{3i} dW_t^i,\\ dX_t^4 = [\theta_4 + X_t^1 + X_t^2] dt + \sum_{i=1}^4 \sigma_{4i} dW_t^i,\\ dX_t^5 = [\theta_5 + X_t^1 + X_t^2] dt + \sum_{i=1}^5 \sigma_{5i} dW_t^i.}
#'
#' The `interest_rate` models return paths generated from the first 3 equations,
#' while the `interest_house_stock` models return paths generated from all 5 equations.
#' The vector \eqn{(\theta_1,\cdots,\theta_5)^\top} is interpreted as the mean
#' vector, \eqn{K = (\kappa_{ij})} is the mean-reversion matrix, and
#' \eqn{\Sigma = (\sigma_{ij})} is the covariance matrix. Estimation of these
#' parameters are in note (a).
#'
#' **Choosing an Appropriate Model:**
#'
#' * Choosing between models `interest_rate` and `interest_house_stock`:
#'
#'     The `interest_house_stock` model assumes dependency between interest rates,
#' stock prices, and house indexes. Therefore, this model takes a more holistic
#' view on the movements of those financial variables.
#'
#'     However, a drawback is that the simulated `interest_house_stock` paths will
#' be more volatile than the `interest_rate` model, and the paths will take
#' longer to revert to mean levels.
#'
#'     If users' intended area of usage is not influenced by stocks and house prices,
#' the `interest_rate` model would be a good choice. If, otherwise, comovements
#' among the financial variables are deemed important, the `interest_house_stock`
#' model is suggested.
#'
#' * Choosing between "independent" and "correlated" factor models:
#'
#'      The correlated-factor model assumes correlation among level, slope, and
#' curvature of the interest rate term structure, while the independent-factor
#' model does not. Note that stock prices and house indexes are always
#' correlated with the interest rate.
#'
#'     The correlated-factor model takes a more holistic view on the underlying
#' term structure of interest. Meanwhile, "correlated" model generates more
#' volatile simulations, and it takes longer to revert to mean levels.
#'
#' * Choosing between discrete- and continuous-time models:
#'
#'     The outputs are different for the two simulators, users should choose the
#' model based on their objectives.
#'
#'     The base time step for discrete-time model is one quarter, whereas there is
#' no such as a base for continuous-time. For time steps smaller than one
#' quarter, discrete-time model will interpolate the quarterly statistics,
#' whereas the continuous-time model simply generates random noises for each
#' specific time step. Consequently, for large time steps, the executing time
#' for continuous-time models are shorter than the dicrete-time model.
#'
#' **Notes:**
#'
#' (a) Procedure for parameter estimation:
#'
#' * Under the real-world measure, computed measurement equation and state
#' transition equation.
#'
#' * Applied Kalman filtering to estimate the parameters. The maximum likelihood
#' estimators were obtained from the Nelder-Mead algorithm.
#'
#'     Procedure for forecasts: Used the state transition equation: \deqn{X_{t+\Delta t} = \int_0^{\Delta t} \exp(-K s) ds \theta + \exp(-K\Delta t) X_t + \eta_t,\ \eta_t \sim \mathcal{N} (0,Q),\\ Q = \int_0^{\Delta t} \exp(-K s) \Sigma \Sigma^\top \exp(-K^\top s) ds.}
#'
#'     Detailed R codes for parameter estimation can be found in the economic tutorial/economic.
#'
#' (b) Large values of percentage change can appear if the original forecasts
#' are near-zero, or if the Gaussian noise is large, though with low probabilities.
#' This happens especially for interest rates in the first few periods due to
#' historical-low rates in 2021.
#'
#' (c) Negative simulated interest rates are allowed since the Arbitrage-Free
#' Nelson Siegel model does not impose non-negativity constraints. On the other
#' hand, the stock prices and home value indexes must be positive, since
#' simulations were done using log transforms, which is an implicit assumption
#' of Geometric Brownian Motions.
#'
#'@references
#'
#' Christensen, J. H., Diebold, F. X. & Rudebusch, G. D. (2011), ‘The affine arbitrage-free class of nelson–siegel term structure models’, _Journal of Econometrics_ 164(1), 4–20.
#'
#' Christensen, J. H., Lopez, J. A. & Rudebusch, G. D. (2015), ‘Analytical formulas for the second moment in affine models with stochastic volatility’.
#'
#' @param num_years integer denoting number of years to forecast from 01-07-2021, default 5 years
#' @param num_paths  integer denoting the number of simulation paths, default 10 paths
#' @param frequency 'year', 'quarter' or 'month' denoting the simulation frequency, default 'month'
#' @param perc_change set TRUE for outputs to be expressed as period-by-period
#' percent change, default FALSE. The reference level, i.e., the original values
#' in the first output period, will be appended above the percentage changes for
#' each variable and each trajectory. See note (b) in section `details`
#' @param type 'independent' or 'correlated' denoting whether the latent factors
#' are independent of each other, default 'independent'
#' @param model 'interest_rate' or 'interest_house_stock' denoting the output
#' variables, default 'interest_rate'
#' @param seed Specify the seed for simulations, no default
#'
#' @return A list of 40 dataframes containing simulated interest rates from
#' 01-07-2021 with maturities from 1 quarter up to 10 years if model is set to be
#' `interest_rate`, or 42 dataframes containing interest rates, NSW house value
#' index, S&P/ASX200 closing prices if model is set to be `interest_house_stock`.
#' Rows are the trajectories (e.g., `trajectory_1`), columns are the time steps
#' (e.g., `2021-07-01`). See note (c) for explanations on the negativity of output
#' values.
#' @export esg_afns_simulator
#'
#' @examples # simulate 10 years of data
#' sim <- esg_afns_simulator(num_years = 10, num_paths = 10, frequency = 'year', type = 'independent', model = 'interest_house_stock', seed = 1)
#'
#' # suppose we wish to look at the 3-month zero-coupon bond rates
#' sim$maturity_1qtrs
#'
#' # suppose we wish to look at the 5-year zero-coupon bond rates
#' sim$maturity_20qtrs
#'
#' # NSW house value index
#' sim$house_index
#'
#' # S&P/ASX200 closing price
#' sim$stock_price
esg_afns_simulator = function (num_years = 5, num_paths = 10, frequency = "month", perc_change = FALSE, type = "independent", model = "interest_rate", seed = NULL) {

    ##################
    # error messages #
    ##################
    is.wholenumber = function(x, tol = .Machine$double.eps^0.5)  abs(x - round(x)) < tol
    if (num_years <= 0 | num_paths <= 0 | !is.wholenumber(num_years) | !is.wholenumber(num_paths)) {
        stop("Number of years and paths to simulate must be positivie integers. ")

    } else if (!frequency %in% c("year", "quarter", "month")) {
        stop ("Frequency must be one of 'year', 'quarter', and 'month'. ")

    } else if (!type %in% c("independent", "correlated")) {
        stop ("Type must be either 'independent' or 'correlated'. ")

    } else if (!model %in% c("interest_rate", "interest_house_stock")) {
        stop ("Model must be either 'interest_rate' or 'interest_house_stock'. ")
    } else if (!is.logical(perc_change)) {
        stop ("perc_change must be logical. ")

    }

    AFNS = afns_model(model, type, frequency)
    {
        init_zcp = AFNS$init_zcp
        mat_qtrs = AFNS$mat_qtrs
        num_xt = AFNS$num_xt
        num_zcp = AFNS$num_zcp
        mu0 = AFNS$mu0
        h = AFNS$h
        Q_est = AFNS$Q_est
        EK_est = AFNS$EK_est
        init_xt = AFNS$init_xt
        KP_est = AFNS$KP_est
        theta_est = AFNS$theta_est
        lambda_est = AFNS$lambda_est
        B_fitted = AFNS$B_fitted
        A_fitted = AFNS$A_fitted
    }

    ##################
    # initialisation #
    ##################

    init_qtr = as.Date("2021-06-01")
    path_index = paste("trajectory_", 1:num_paths, sep = "")

    num_pred = num_years / h
    time_index = seq(from = init_qtr, length.out = num_pred+1, by = frequency)[-1]
    progression = floor(num_paths*num_pred / 5)

    ###############
    # simulate Xt #
    ###############

    Xt_sim = replicate(n = num_paths,
                        expr = {data.frame(matrix(NA, nrow = num_xt, ncol = num_pred+1))},
                        simplify = F)
    Xt_sim = lapply(Xt_sim, function (x) {x[,1] = init_xt; return (x)})
    set.seed(seed)
    noise = MASS::mvrnorm(num_paths*num_pred, mu = mu0, Sigma = Q_est)
    noise_ind = 1; prog_ind = 1
    cat("Progress: 0% \n")
    for (path in 1:num_paths) {
        for (i in 2:(num_pred+1)) {
            eta = as.matrix(noise[noise_ind,])
            Xt = as.matrix(Xt_sim[[path]][,i-1])
            Xt_sim[[path]][,i] = EK_est %*% theta_est + expm::expm(-h * KP_est) %*% Xt + eta
            noise_ind = noise_ind + 1
            if (noise_ind == progression * prog_ind && prog_ind < 5) {
                cat(paste(20*prog_ind, "%\n", sep = ""))
                prog_ind = prog_ind + 1
            }
        }
    }

    ##############
    # compute yt #
    ##############

    zcp_sim = replicate(n = num_paths,
                        expr = {matrix(NA, nrow = num_pred+1, ncol = num_zcp)},
                        simplify = F)
    zcp_sim = lapply(1:num_paths,
                     function (x) {zcp_sim[[x]] = t(B_fitted %*% as.matrix(Xt_sim[[x]])) - A_fitted})
    zcp_sim = lapply(zcp_sim,
                     function(x){x = as.data.frame(x)[-1,];
                                 row.names(x) = as.character(time_index);
                                 colnames(x) = mat_qtrs; return (x) })

    ###################
    # reorganise data #
    ###################

    output = zcp_sim
    output = lapply(1:num_zcp,
                    function (x) {lapply(1:num_paths, function (y) {zcp_sim[[y]][,x]})})
    output = lapply(output,
                    function(x){x = as.data.frame(x);
                                row.names(x) = as.character(time_index);
                                colnames(x) = path_index; return (x)})
    names(output) = mat_qtrs
    if (model == "interest_house_stock") {
        output[[41]] = exp(output[[41]])
        output[[42]] = exp(output[[42]])
    }
    output = lapply(output, function (x) {x = t(x)})

    #############
    # Adj units #
    #############

    if (isTRUE(perc_change)) {
        ref_level = lapply(output, function (x) {x = as.data.frame(x[,1]); colnames(x) = paste("ref_level", time_index[1]);x})
        output = lapply(output, function (x) {(x[,-1] - x[,-ncol(x)]) / x[,-ncol(x)]})
        output = lapply(1:length(output), function (x) {cbind(ref_level[[x]],output[[x]])}) # include the reference level in outputs
        names(output) = mat_qtrs
    }

    cat("100% \n")
    return (output)
}
